{
  "articles": [
    {
      "path": "02-methodology.html",
      "title": "Methodology",
      "description": "Some additional details about the website\n",
      "author": [],
      "contents": "\nSetting Up\nLinear Threshold Model (LTM) is one of the famous models simulating the spread of influence in networks. Continuing with the movie-inspired analogy, let’s delve into the mechanics of how influence spreads through a network, denoted as \\(G\\). In this directed network, each individual is represented as a node, categorized as either active (an adopter of the idea) or inactive. Drawing from our motivation, the general assumption is that each node tends to become active.\nNow, let’s consider the process in which nodes transition from being inactive to active. This transition occurs monotonically, meaning nodes can only shift from being inactive to active, but not the other way around. Thus, as time progresses, more and more of a node \\(v\\)’s neighbors become active. At some point, a neighbor node \\(w\\) influences \\(v\\) to become active, triggering further decisions among other nodes connected to \\(v\\).\nLinear Threshold Model (LTM)\nIn the Linear Threshold model, a node \\(v\\) is influenced by each neighbor \\(w\\) with a weight \\(b_{v,w}\\) such that\n\\[\\sum_{w \\text{ neighbor of v}} b_{v,w} \\le 1\\]\n. Each node \\(v\\) has a threshold \\(\\theta_v\\) which is randomly drawn from the uniform distribution over the interval \\([0,1]\\), representing the different levels of tendency for each node to adopt the idea from their neighbors.\nWith a given a random threshold and an initial set of active nodes \\(A_0\\) (while all other nodes are inactive), the model operates in discrete steps. In step \\(t\\), all nodes that are active in step \\(t-1\\) remain active, and any inactive node \\(v\\) in step \\(t-1\\) becomes active if the weighted sum of its active neighbors is at least \\(\\theta_v\\):\n\\[\\sum_{w\\text{ active neighbors of v}} b_{v,w}\\ge \\theta_v\\]\nInfluence Maximization Problem\nThe Influence Maximization Problem focuses on finding the best starting nodes to kick off the spread of influence in a network. It’s all about figuring out: Where should we begin to maximize the nodes’ impact?\nTo crack this problem, we define the influence of a set of nodes \\(A\\), denoted as \\(\\sigma(A)\\), as the expected number of active nodes at the end of the process, assuming \\(A\\) is our initial set of active nodes \\(A_0\\). So, the goal of the influence maximization problem is to identify the best initial set of nodes \\(A_0\\), given a certain number \\(k\\) where \\(k\\in \\bf{N}\\), to maximize our influence.\nThis problem is important because it helps us understand how information or behavior spreads in networks. By finding the most influential starting points, we can set off a chain reaction that gets more and more people on board with our idea or action. This matters a lot in areas like marketing, where we want to reach as many customers as possible, in disease control, where we aim to stop outbreaks before they spread, and in understanding social networks, where we want to see how trends catch on among groups of people.\nApporximation for Influence Maximization\nHowever, it turns out that the influence maximization problem is acutally NP-hard, meaning that it could not be solved in polynomial time (assuming \\(P\\neq NP\\)). Thus, solving it efficiently isn’t straightforward–it’s a really complex problem that could take a long time to solve, especially as the size of the network is huge (Processing 30,000 nodes will take days to complete).\nTherefore, the best approach will be approximating the influence maximization problem. Here are several approximation guarantees to ensure that the following approximation method works.\nFor an arbitrary instance of Linear Threshold Model, the resulting influence function \\(\\sigma(\\cdot)\\) is submodular.\n\\(\\sigma(\\cdot)\\) is submodular if it exhibits the “diminishing marginal returns”, meaning that the marginal gain from adding a element to a set \\(S\\) is at least as high as the marginal gain from adding the same element to \\(T\\) where \\(S\\in T\\). Mathematically, this is represented as: \\(f(S\\cup \\{v\\})-f(S) \\ge f(T\\cup \\{v\\})-f(T), \\forall\\) elements \\(v\\) and all pairs of sets \\(S\\in T\\).\nSubmodularity is important because it guarantees that the greedy algorithm’s approximation will not overshoot the optimal solution too much. Specifically, it ensures that the marginal gain achieved by adding a node to the seed set diminishes as the size of the seed set increases. This property allows the greedy algorithm to make locally optimal decisions at each step.\nThis also implies that \\(\\sigma(\\cdot)\\) is also a monotone function. This means that adding an element to the set cannot make the overall influence decrease, which aligns with the intuitive expectation that more influencers lead to more influence.\n\nAlgorithm: Greedy Hill-Climbing\nOne proposed approximation strategy is to use the greedy hill-climbing.\nGreedy hill-climbing is an iterative algorithm that begins with an arbitrary solution to a problem and then tries to enhance it by making small incremental adjustments. If a change results in a better solution, the algorithm adopts it and continues making further adjustments until no further improvements can be made.\nIn the context of the influence maximization problem, we employ greedy hill-climbing to identify the most influential nodes. We begin with an empty active set \\(A_0\\). At each step \\(i\\), the algorithm selects one node to activate, aiming to maximize its influence on the network. However, it’s important to note that this approach may only lead to finding local maximum seed nodes, rather than a globally optimal solution.\nThis approach achieves an approximation ratio of 63% but performs fairly slow and not salable.\n\n\n\n",
      "last_modified": "2024-04-24T14:21:04-05:00"
    },
    {
      "path": "03-algorithm.html",
      "title": "R code",
      "description": "In this section, we are going to explore the implementation of linear threshold model in R studio. \n",
      "author": [],
      "contents": "\nRandom Graph Set up\n\n\nlibrary(tidyverse)\nlibrary(ggpubr)\nlibrary(igraph)\nlibrary(poweRlaw)\nlibrary(ggformula)\nlibrary(data.table)\nlibrary(graphics)\nlibrary(knitr)\nlibrary(rmarkdown)\n\ntheme_set(theme_bw())\n\n\n\n\n# Function to create a random graph with edge weights satisfying the constraint\ncreate_weighted_random_graph <- function(num_nodes) {\n  # Generate a random graph with 'num_nodes' nodes\n  random_graph <- erdos.renyi.game(num_nodes, p = 0.1, directed = TRUE)\n  \n  # Initialize the graph with zero edge weights\n  Ew <- matrix(0, nrow = num_nodes, ncol = num_nodes)\n  \n  # Loop through each node\n  for (v in 1:num_nodes) {\n    neighbors <- neighbors(random_graph, v, mode = \"in\")\n    \n    # Assign edge weights inversely proportional to the number of edges connected to node 'v'\n    num_neighbors <- length(neighbors)\n    if (num_neighbors > 0) {\n      weight <- 1 / num_neighbors\n      for (w in neighbors) {\n        Ew[w, v] <- weight\n      }\n    } else {\n      # Set edge weight to 0 if the number of neighbors is 0\n      # Loop through all nodes to ensure zero weights are assigned\n      for (w in 1:num_nodes) {\n        Ew[w, v] <- 0\n      }\n    }\n  }\n  \n  \n  # Create a weighted graph from the adjacency matrix with edge weights\n  weighted_random_graph <- graph_from_adjacency_matrix(Ew, mode = \"directed\", weighted = TRUE)\n  \n  return(weighted_random_graph)\n}\n\n# Create a random graph with 50 nodes and edge weights satisfying the constraint\nrandom_graph_50 <- create_weighted_random_graph(50)\n\n# Plot the random graph\npar(mar=c(0,0,0,0)+.1)\nplot.igraph(random_graph_50, \n     edge.width = E(random_graph_50)$weight, \n     edge.arrow.size=0.4,\n     layout = layout.circle,\n     vertex.size=13, \n     vertex.color = \"#A9AABC\")\n\n\n\nLiner Threshold Model\n\n\n# Function to calculate uniform edge weights\n## Every incoming edge of v with degree dv has weight 1/dv.\nuniformWeights <- function(G) {\n  # Initialize empty list to store edge weights\n  Ew <- list()\n  # Loop over edges in the graph\n  for (e in E(G)) {\n    # Get the target node of the edge\n    v <- ends(G, e)[2]\n    # Calculate the degree of the target node\n    dv <- degree(G, v, mode = \"in\")\n    # Assign weight to the edge\n    Ew[[as.character(e)]] <- 1 / dv\n  }\n  return(Ew)\n}\n\n# Function to calculate random edge weights \n## Every edge has random weight. After weights assigned, we normalize weights of all incoming edges for each node so that they sum to 1.\nrandomWeights <- function(G) {\n  Ew <- list()  # Initialize empty list to store edge weights\n  # Assign random weights to edges\n  for (v in V(G)) {\n    in_edges <- incident(G, v, mode = \"in\")  # Get incoming edges for the current node\n    ew <- runif(length(in_edges))  # Generate random weights for incoming edges\n    total_weight <- sum(ew)  # Calculate the total weight of incoming edges\n    # Normalize weights so that they sum to 1 for each node\n    ew <- ew / total_weight\n    # Store the weights for the incoming edges\n    for (i in seq_along(in_edges)) {\n      Ew[[as.character(in_edges[i])]] <- ew[i]\n    }\n  }\n  return(Ew)\n}\n\n\n# Function to run linear threshold model\nrunLT <- function(G, S, Ew) {\n  T <- unique(S)  # Targeted set with unique nodes\n  lv <- sapply(V(G), function(u) runif(1))  # Threshold for nodes\n  W <- rep(0, vcount(G))  # Weighted number of activated in-neighbors\n  Sj <- unique(S)\n  \n  while (length(Sj) > 0) {\n    if (length(T) >= vcount(G)) {\n      break  # Break if the number of active nodes exceeds or equals the total number of nodes in G\n    }\n    Snew <- c()\n    for (u in Sj) {\n      neighbors <- neighbors(G, u, mode = \"in\")\n      for (v in neighbors) {\n        e <- as.character(get.edge.ids(G, c(v, u)))  # Define 'e' as the edge index\n        if (!(v %in% T)) {\n          # Calculate the total weight of the activated in-neighbors\n          total_weight <- sum(Ew[[e]])\n          \n          # Update the weighted number of activated in-neighbors\n          W[v] <- W[v] + total_weight\n          \n          # Check if the threshold is exceeded\n          if (W[v] >= lv[v]) {\n            Snew <- c(Snew, v)\n            T <- c(T, v)\n          }\n        }\n      }\n    }\n    Sj <- unique(Snew)  # Ensure unique nodes in the new set\n  }\n  return(T)  # Return all activated nodes\n}\n\n\n# Function to calculate the total number of active nodes at each iteration\nactiveNodes <- function(G, S, Ew, iterations) {\n  active_df <- data.frame(iteration = integer(), \n                          total_active_nodes = integer())\n  total_active_nodes <- rep(0, iterations)  # Initialize empty vector to store total active nodes\n  \n  for (i in 1:iterations) {\n    T <- runLT(G, S, Ew)\n    message(\"--\", i,\"T:  \", T, \"\\n\")\n    total_active <- length(unique(T))  # Calculate the total active nodes in this iteration\n    total_active_nodes[i] <- total_active  # Update total active nodes for current iteration\n    \n    # Limit total active nodes to the number of nodes in the graph\n    if (total_active_nodes[i] >= vcount(G)) {\n      total_active_nodes[i] <- vcount(G)  \n    }\n    \n    # Update data frame with current iteration's total active nodes\n    active_df <- rbind(active_df, data.frame(iteration = i, \n                                             total_active_nodes = total_active_nodes[i]))\n    \n    # Update seed set S for the next iteration\n    S <- unique(c(S, T))\n  }\n  return(active_df)\n}\n\n\nExample Usage for LTM\n\n\nset.seed(123)\nrandom_graph_50 <- erdos.renyi.game(50, p = 0.1, directed = TRUE) # random graph set up\nS <- sample(1:vcount(random_graph_50), 3)  # Initial seed set of nodes\n\n# Equal edge weight for node v -> Calculate uniform edge weights\nEw_uniform <- uniformWeights(random_graph_50)\nhead(Ew_uniform)\n\n$`1`\n[1] 0.5\n\n$`2`\n[1] 0.5\n\n$`3`\n[1] 0.25\n\n$`4`\n[1] 0.25\n\n$`5`\n[1] 0.25\n\n$`6`\n[1] 0.25\n\n\n# Scale edge width based on the weights in Ew_uniform\nedge_width <- sapply(E(random_graph_50), function(e) {\n  v <- ends(random_graph_50, e)[2]\n  Ew_uniform[[as.character(e)]]\n})\n\n# Plot seed dots\npar(mar=c(0,0,0,0)+.1)\nplot.igraph(random_graph_50, \n     edge.width = edge_width, \n     edge.arrow.size=0.4,\n     layout = layout.circle,\n     vertex.size=13, \n     vertex.color = ifelse(1:vcount(random_graph_50) %in% S, \"#FC888F\",\"#A9AABC\"))\n\n\n\n\n## Run Linear Threshold model with uniform edge weights\n# activated_nodes <- runLT(random_graph_50, S, Ew_uniform) # single iteration\n# activated_nodes\n\nactive_df1 <- activeNodes(random_graph_50, S, Ew_uniform, iterations = 10)\npaged_table(active_df1)\n\n\n\n\n\nactive_df2 <- activeNodes(random_graph_50, S, Ew_uniform, iterations = 10)\nactive_df3 <- activeNodes(random_graph_50, S, Ew_uniform, iterations = 10)\nactive_df4 <- activeNodes(random_graph_50, S, Ew_uniform, iterations = 10)\nactive_df5 <- activeNodes(random_graph_50, S, Ew_uniform, iterations = 10)\n\nactive_df <- active_df1 %>% \n  left_join(active_df2, by = \"iteration\") %>% \n  left_join(active_df3, by = \"iteration\") %>% \n  left_join(active_df4, by = \"iteration\") %>% \n  left_join(active_df5, by = \"iteration\") %>% \n  rename(df1 = total_active_nodes.x,\n         df2 = total_active_nodes.y,\n         df3 = total_active_nodes.x.x,\n         df4 = total_active_nodes.y.y,\n         df5 = total_active_nodes)\n\nactive_df %>% \n  ggplot() + \n  geom_line(aes(x = iteration, y = df1, color = \"df1\"), linetype = \"solid\") + \n  geom_line(aes(x = iteration, y = df2, color = \"df2\"), linetype = \"solid\") + \n  geom_line(aes(x = iteration, y = df3, color = \"df3\"), linetype = \"solid\") + \n  geom_line(aes(x = iteration, y = df4, color = \"df4\"), linetype = \"solid\") + \n  geom_line(aes(x = iteration, y = df5, color = \"df5\"), linetype = \"solid\") +\n  scale_color_manual(values = c(\"#5E71C2\", \"#454655\", \"#A9AABC\", \"#C0535D\", \"#FC888F\")) +\n  ylab(\"total_active_nodes\") + \n  labs(color = \"Data\", \n       title = \"Active Nodes over Iterations\", \n       subtitle = \"3 random seed nodes with uniform edge weights\") +\n  theme(legend.position = c(0.97, 0.02),\n        legend.justification = c(1, 0),\n        legend.box.background = element_rect(color = \"black\", linewidth = 0.5),\n        legend.box.just = \"top\")\n\n\n\n\n\nset.seed(123)\n# random_graph_50 <- erdos.renyi.game(50, p = 0.1, directed = TRUE) # random graph set up\n# S <- sample(1:vcount(random_graph_50), 3)  # Initial seed set of nodes\n\n## Calculate random edge weights -> Random edge weights, then normalized to sum <= 1\nEw_random <- randomWeights(random_graph_50)\nhead(Ew_random)\n\n$`1`\n[1] 0.2672945\n\n$`2`\n[1] 0.7327055\n\n$`3`\n[1] 0.1795319\n\n$`4`\n[1] 0.3876253\n\n$`5`\n[1] 0.4128445\n\n$`6`\n[1] 0.0199983\n\n\n# Scale edge width based on the weights in Ew_uniform\nedge_width <- sapply(E(random_graph_50), function(e) {\n  v <- ends(random_graph_50, e)[2]\n  Ew_random[[as.character(e)]]\n})\n\n# Plot seed dots\npar(mar=c(0,0,0,0)+.1)\nplot.igraph(random_graph_50, \n     edge.width = edge_width, \n     edge.arrow.size=0.4,\n     layout = layout.circle,\n     vertex.size=13, \n     vertex.color = ifelse(1:vcount(random_graph_50) %in% S, \"#FC888F\",\"#A9AABC\"))\n\n\n\n# Run Linear Threshold model with uniform edge weights\n# activated_nodes <- runLT(random_graph_50, S, Ew_random) # single iteration\n# activated_nodes\n\nactive_df1 <- activeNodes(random_graph_50, S, Ew_random, iterations = 10)\npaged_table(active_df1)\n\n\n\n\n\nactive_df2 <- activeNodes(random_graph_50, S, Ew_random, iterations = 10)\nactive_df3 <- activeNodes(random_graph_50, S, Ew_random, iterations = 10)\nactive_df4 <- activeNodes(random_graph_50, S, Ew_random, iterations = 10)\nactive_df5 <- activeNodes(random_graph_50, S, Ew_random, iterations = 10)\n\nactive_df <- active_df1 %>% \n  left_join(active_df2, by = \"iteration\") %>% \n  left_join(active_df3, by = \"iteration\") %>% \n  left_join(active_df4, by = \"iteration\") %>% \n  left_join(active_df5, by = \"iteration\") %>% \n  rename(df1 = total_active_nodes.x,\n         df2 = total_active_nodes.y,\n         df3 = total_active_nodes.x.x,\n         df4 = total_active_nodes.y.y,\n         df5 = total_active_nodes)\n\nactive_df %>% \n  ggplot() + \n  geom_line(aes(x = iteration, y = df1, color = \"df1\"), linetype = \"solid\") + \n  geom_line(aes(x = iteration, y = df2, color = \"df2\"), linetype = \"solid\") + \n  geom_line(aes(x = iteration, y = df3, color = \"df3\"), linetype = \"solid\") + \n  geom_line(aes(x = iteration, y = df4, color = \"df4\"), linetype = \"solid\") + \n  geom_line(aes(x = iteration, y = df5, color = \"df5\"), linetype = \"solid\") +\n  scale_color_manual(values = c(\"#5E71C2\", \"#454655\", \"#A9AABC\", \"#C0535D\", \"#FC888F\")) +\n  ylab(\"total_active_nodes\") + \n  labs(color = \"Data\", \n       title = \"Active Nodes over Iterations\", \n       subtitle = \"3 random seed nodes with random edge weights\") +\n  theme(legend.position = c(0.97, 0.02),\n        legend.justification = c(1, 0),\n        legend.box.background = element_rect(color = \"black\", linewidth = 0.5),\n        legend.box.just = \"top\")\n\n\n\nGreedy Algorithm for LTM\n\n\n# Function to calculate average size of activated nodes\navgLT <- function(G, S, Ew, iterations) {\n  avgSize <- 0\n  for (i in 1:iterations) {\n    T <- runLT(G, S, Ew)\n    avgSize <- avgSize + length(T) / iterations\n  }\n  return(avgSize)\n}\n\n\n# Define the Greedy_LTM function\nGreedy_LTM <- function(G, Ew, k, iterations) {\n  start <- Sys.time()  # Record the start time\n  S <- c()  # Initialize the seed set\n  \n  for (i in 1:k) {\n    inf <- vector(mode = \"list\", length = vcount(G))  # Initialize the influence for nodes not in S\n    \n    # Calculate the influence for nodes not in S\n    for (v in V(G)) {\n      if (!(v %in% S)) {\n        inf[[as.character(v)]] <- avgLT(G, c(S, v), Ew, iterations)\n      }\n    }\n    \n    # Select the node with maximum influence and add it to the seed set\n    u <- which.max(unlist(inf))\n    print(paste(\"Selected node:\", u, \"with influence:\", max(unlist(inf))))\n    S <- c(S, as.numeric(u)) # Convert node name to numeric and add it to seed set\n  }\n  \n  end <- Sys.time()  # Record the end time\n  # Print the total time taken\n  print(paste(\"Total time:\", end - start))\n  \n  return(S)  # Return the seed set\n}\n\n\nExample: Greedy Algorithm of Influence Max Problem on LTM\n\n\nset.seed(123)\nrandom_graph <- erdos.renyi.game(50, 0.1, directed = TRUE)\n# Calculate uniform edge weights\nEw_uniform <- uniformWeights(random_graph)\n\navg_size_uniform <- avgLT(random_graph, S, Ew_uniform, iterations = 10)\navg_size_uniform\n\n[1] 25.4\n\n\n# Run the Greedy_LTM function\nseed_set <- Greedy_LTM(random_graph, Ew_uniform, k = 3, iterations = 10)\n\n[1] \"Selected node: 48 with influence: 16.3\"\n[1] \"Selected node: 16 with influence: 23.6\"\n[1] \"Selected node: 1 with influence: 26.2\"\n[1] \"Total time: 1.79875087738037\"\n\nseed_set\n\n[1] 48 16  1\n\n\nactive_df_selectedSeed <- activeNodes(random_graph, seed_set, Ew_uniform, iterations = 20)\npaged_table(active_df_selectedSeed)\n\n\n\n\n\nS <- sample(1:vcount(random_graph_50), 3)  # Initial seed set of nodes\nactive_df_randomSeed <- activeNodes(random_graph, S, Ew_uniform, iterations = 20)\npaged_table(active_df_randomSeed)\n\n\n\n\n\n\n\n",
      "last_modified": "2024-04-24T14:21:11-05:00"
    },
    {
      "path": "03-results.html",
      "title": "Results",
      "description": "In this section, we are going to explore the implementation of linear threshold model in R studio. \n",
      "author": [],
      "contents": "\n\n\n\n",
      "last_modified": "2024-04-24T14:21:11-05:00"
    },
    {
      "path": "04-application.html",
      "title": "Application",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\n\n\n\n",
      "last_modified": "2024-04-24T14:21:11-05:00"
    },
    {
      "path": "index.html",
      "title": "Linear Threshold Models",
      "description": "By Wenxuan Zhu\n\nWelcome to the website. I hope you enjoy it!\n",
      "author": [],
      "contents": "\nIntro to Graphs\nGraphs (networks) are visual representations of connections between things. They consist of dots (nodes) connected by lines (edges). Graphs help us understand how things are related and how information flows in systems like social networks, transportation routes, and more.\nSpread of Influence\nImagine you’re planning a movie night with your friends. You suggest watching a new superhero movie, but not everyone is immediately on board. However, you know that once a few friends agree to watch it, they’ll start convincing others to join in.\nIn this scenario, your social circle forms a network where each person’s decision to watch the movie is influenced by their connections. When one friend agrees to watch, they start spreading the excitement to other connected peers in the network. Soon enough, more and more friends agree with the superhero movie bandwagon.\nThis simple example illustrates how influence can spread through a network, starting with just a few initial adopters and gradually reaching a larger portion of the group as the excitement/agreement spreads from friend to friend.\nAcknowledgement\nA huge thank you to my professor Andrew Beveridge for delivering this amazing Network Science capstone class. Your expertise and passion have truly enriched our learning experience. :)\n\n\n\n",
      "last_modified": "2024-04-24T14:21:12-05:00"
    }
  ],
  "collections": []
}
